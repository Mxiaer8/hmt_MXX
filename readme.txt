关于项目：
1. 首页界面
     问题：我发现原官网有个弊端，就是在首页的视频播放完成之后，视频停留在了播放结束后的画面，若要重新播放视频，需点击网页进行刷新，才可重新播放。
     解决：对此，在hometown里面添加了video.onended = function()函数，用于在视频播放结束后，将视频隐藏，并重新显示播放按钮，使用户有更好的体验

2. 产品介绍界面
     问题：此界面遇到的最大问题是左侧栏的轮播图效果。并且发现原网页有两个弊端，①当点击轮播图的左按钮或右按扭的时候，轮播图在点击之后，将不再实现动画效果。②在实现自适应的过程中，轮播图显示的图片尺寸，出现差错。
     解决：经过思考原理，利用了html中的ul标签以及配合js中setTimeout()的方法实现了轮播图的自动播放效果，即使在用户点击左右按钮之后，轮播图仍以原来的效果继续播放。并且，通过设置轮播图左移的宽度自适应于网页后，解决了轮播图在网页自适应中图片不完整的弊端。其中再利用jquery进一步实现了动画效果

3. 历史介绍界面
     问题：此界面最大的难点在于jquery效果实现，涉及到轮播图的实现，以及相应文字介绍的滑出
     解决：通过查阅资料，利用了jquery的slideDown()函数实现底部效果的滑出，以及利用jquery的fadeIn()以及fadeOut()函数实现了文本效果的淡入淡出。

4. 关于我们界面
     问题：此界面最大难点在于底部福利点击效果的实现
     解决：利用jquery的fadeIn()、hide()、fadeout()以及show()函数实现了福利框的淡入、隐藏、福利内容的淡出、显示等效果
     （说明：本界面在实现鼠标移动到对应头像部分。只实现了胖先生的效果以及林建明同学的效果，因涉及到多处重复设置，因此只实现两个人的效果仅供参考）

综上所述：
	在此项目中有非常大的收获
	1.认识到对div的设定为百分比的重要性，通过百分比的设定，使每个元素都会随着页面的宽度与高度自动适应，这是非常重要的！
	2.了解到关于多个div不换行处理
	通过查阅资料，了解到有两种方法可以实现
① 通过对每个div的css设定为inline-block属性
② 通过对每个div的css设定为float-left属性
	此方法具体也通过本人的csdn博客	（https://blog.csdn.net/zhenzuo_x/article/details/79945669）进一步具体的讲解出来。
	3. 对于position的应用，对于position的css属性有两种:absolute以及relative 对于在适当的地方运用相对应的属性是相当重要。
	4.关于页面兼容性的处理，对于不同的页面，同样的css可能呈现不同的效果，对此可以在每个css开头设置所有元素的默认值为0以达到一致的效果
	5.对盒子模型有更深的认识
	6.关于对jq的引用，本次项目是通过百度cdn地址引用jquery库，需连接上网络才可看到网页的实际效果，关于对cdn的引用：使用百度、又拍云、新浪、谷歌或微软的 jQuery，有一个很大的优势，许多用户在访问其他站点时，已经从百度、又拍云、新浪、谷歌或微软加载过 jQuery。所以结果是，当他们访问我们页面的站点时，会从缓存中加载 jQuery，这样可以减少加载时间。同时，大多数 CDN 都可以确保当用户向其请求文件时，会从离用户最近的服务器上返回响应，这样也可以提高加载速度。
	
	
关于阅读js高级程序语言的笔记:（具体的读书笔记划在书上）
关于前五章：
	为基本js语法，同c语言相差不多
需要注意的为以下知识点：
1.关于输出部分，通常可以用console.log()此函数，用于对代码的相应测试
2.关于变量部分，用var关键字申明即好
3.关于函数的基本语法为：
function myFunction()
{
    alert("Hello World!");
}
第五章之后：
	主要为面向对象方面的内容，同java语言有一定的相似程度
其中关于对闭包的学习：
可通过一个例子举例进行理解
var add = (function () {
    var counter = 0;
    return function () {return counter += 1;}
})();
 
add();
add();
add(); 
// 计数器为 3

理解如下：我们通常会想当然的认为每次调用 add() 都会重走一遍add()中的代码块, 但其实不然。
注意add方法中的return, 它return的并不是1,2,3这样的数值,而是return了一个方法,并且把这个方法赋值给了add变量。
那么在这个function自运行一遍之后,其实最后赋值给add的是return counter += 1 这段代码。
所以后面每次调用add() 其实都是在调用return counter += 1。
再结合文章之前所说的, 闭包会持有父方法的局部变量并且不会随父方法销毁而销毁, 所以这个counter其实就是来自于第一次function执行时创建的变量。
